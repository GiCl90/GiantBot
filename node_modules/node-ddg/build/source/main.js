"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const cheerio_1 = __importDefault(require("cheerio"));
const puppeteer_1 = __importDefault(require("puppeteer"));
const query_string_1 = __importDefault(require("query-string"));
var SafeSearchEnum;
(function (SafeSearchEnum) {
    SafeSearchEnum[SafeSearchEnum["OFF"] = -2] = "OFF";
    SafeSearchEnum[SafeSearchEnum["MODERATE"] = -1] = "MODERATE";
    SafeSearchEnum[SafeSearchEnum["ON"] = 1] = "ON";
})(SafeSearchEnum = exports.SafeSearchEnum || (exports.SafeSearchEnum = {}));
// Init default options
const defaultOptions = {
    maxResults: 5,
    query: null,
    safeSearch: SafeSearchEnum.MODERATE,
    secure: true
};
// Init protocols
const protocols = {
    http: 'http://',
    https: 'https://'
};
// Init the endpoint
const endpoint = 'www.duckduckgo.com/?';
/**
 * @function search
 * @description Returns the title, body and link of searched queries from DuckDuckGo.
 * @param options Search options
 * @param options.maxResults Max results to return, defaults to `5`
 * @param options.query Search query, required
 * @param options.safeSearch Safe Search setting as defined in https://duckduckgo.com/params, defaults to `MODERATE`
 * @param options.secure Whether to use HTTPS or HTTP, defaults to `true`
 * @license MIT
 */
async function search(options) {
    // Make sure there is a query to search for
    if (options.query === null || options.query.length === 0) {
        return Promise.reject(new Error('The search query cannot be empty.'));
    }
    // Init the options with the default options and then the passed through options
    const opts = Object.assign(Object.assign({}, defaultOptions), options);
    // For parameter explanations, see https://duckduckgo.com/params
    const parameters = query_string_1.default.stringify({
        kd: -1,
        kp: opts.safeSearch,
        kz: -1,
        q: opts.query
    });
    // Create a new Browser and a Page
    const browser = await puppeteer_1.default.launch({
        args: ['--no-sandbox'],
        timeout: 60000
    });
    const page = await browser.newPage();
    // Create the url and go to it
    const searchUrl = `${opts.secure ? protocols.https : protocols.http}${endpoint}${parameters}`;
    await page.goto(searchUrl);
    // Wait for web content wrapper to load
    await page.waitFor('#web_content_wrapper');
    // Get the results HTML, we tell Istanbul/Jest's Codecov to ignore the function inside page.evaluate
    // because Istanbul can't access it as Puppeteer is going to execute it outside Node
    const html = await page.evaluate(
    /* istanbul ignore next */ () => {
        // eslint-disable-next-line no-undef
        return [...document.querySelectorAll('#links')].map((val) => val.innerHTML);
    });
    // If there's no results found reject with the appropriate error
    if (html[0].indexOf('No results found for') > 0) {
        if (options.safeSearch === SafeSearchEnum.ON) {
            await browser.close();
            return Promise.reject(new Error('No results were found because SafeSearch is enabled.'));
        }
        await browser.close();
        return Promise.reject(new Error(`No results were found with query: ${opts.query}`));
    }
    // Init the results array
    const results = [];
    // Iterate through results found in the HTML
    for (const result of html) {
        // Load the HTML into Cheerio (jQuery but for Node)
        const $ = cheerio_1.default.load(result, { normalizeWhitespace: true });
        // Iterate through each element found inside specified selector and assign the title/body/url, pushing them
        // into the results array
        $('.result>.result__body').each((index, element) => {
            if (index >= opts.maxResults) {
                return;
            }
            const title = cheerio_1.default(element)
                .find('.result__a')
                .html()
                .replace(/(<b>|<\/b>)/g, '**')
                .trim();
            const body = cheerio_1.default(element)
                .find('.result__snippet')
                .html()
                .replace(/(<b>|<\/b>)/g, '**')
                .trim();
            const url = cheerio_1.default(element)
                .find('.result__url')
                .attr('href')
                .trim();
            results.push({ body, title, url });
        });
    }
    // Before we resolve the results, make sure to close the browser
    await browser.close();
    return results;
}
exports.search = search;
exports.default = search;
